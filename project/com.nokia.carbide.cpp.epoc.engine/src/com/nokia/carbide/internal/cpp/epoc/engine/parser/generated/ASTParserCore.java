/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of the License "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/
/* Generated By:JavaCC: Do not edit this line. ASTParserCore.java */
package com.nokia.carbide.internal.cpp.epoc.engine.parser.generated;

import com.nokia.carbide.internal.api.cpp.epoc.engine.dom.*;
import com.nokia.carbide.internal.cpp.epoc.engine.parser.*;

public class ASTParserCore extends ParserBase implements ASTParserCoreConstants {
    public IASTPreprocessorExpression parse() {
                IASTPreprocessorExpression expr = null;
                try {
                        expr = ppExpression();
                } catch (ParseException e) {
                        //e.printStackTrace();
                        // expr remains null
                }
                return expr;
    }

  final public IASTPreprocessorExpression ppExpression() throws ParseException {
        IASTPreprocessorExpression expr;
    expr = ppTrinaryExpression();
                //setExtendedSourceRangeFromComments(expr, false, false);
                {if (true) return expr;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppTrinaryExpression() throws ParseException {
        IASTPreprocessorExpression cond, lhs = null, rhs = null;
        IASTPreprocessorExpression ret;
    cond = ppLogOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION:
      jj_consume_token(QUESTION);
      lhs = ppTrinaryExpression();
      jj_consume_token(COLON);
      rhs = ppTrinaryExpression();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
                if (lhs != null) {
                        ret = ASTFactory.createPreprocessorTrinaryExpression(cond, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { cond, rhs });
                } else {
                        ret = cond;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppLogOrExpression() throws ParseException {
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppLogAndExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOGOR:
      jj_consume_token(LOGOR);
      rhs = ppLogOrExpression();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper = IASTPreprocessorBinaryExpression.K_LOG_OR;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppLogAndExpression() throws ParseException {
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppBitOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOGAND:
      jj_consume_token(LOGAND);
      rhs = ppLogAndExpression();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper = IASTPreprocessorBinaryExpression.K_LOG_AND;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppBitOrExpression() throws ParseException {
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppBitXorExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OR:
      jj_consume_token(OR);
      rhs = ppBitOrExpression();
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper = IASTPreprocessorBinaryExpression.K_OR;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppBitXorExpression() throws ParseException {
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppBitAndExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case XOR:
      jj_consume_token(XOR);
      rhs = ppBitXorExpression();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper = IASTPreprocessorBinaryExpression.K_XOR;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppBitAndExpression() throws ParseException {
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppEqualExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
      jj_consume_token(AND);
      rhs = ppBitAndExpression();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper = IASTPreprocessorBinaryExpression.K_AND;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppEqualExpression() throws ParseException {
        Token t = null;
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppRelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
    case NE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NE:
        t = jj_consume_token(NE);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rhs = ppEqualExpression();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper = 0;
                        if (t.kind == EQ)
                                oper = IASTPreprocessorBinaryExpression.K_EQUALS;
                        else
                                oper = IASTPreprocessorBinaryExpression.K_NOT_EQUALS;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppRelationalExpression() throws ParseException {
        Token t = null;
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppShiftExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
    case GT:
    case LTE:
    case GTE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        t = jj_consume_token(LT);
        break;
      case GT:
        t = jj_consume_token(GT);
        break;
      case LTE:
        t = jj_consume_token(LTE);
        break;
      case GTE:
        t = jj_consume_token(GTE);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rhs = ppRelationalExpression();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper = 0;
                        switch (t.kind) {
                        case LT:
                                oper = IASTPreprocessorBinaryExpression.K_LESS_THAN;
                                break;
                        case GT:
                                oper = IASTPreprocessorBinaryExpression.K_GREATER_THAN;
                                break;
                        case LTE:
                                oper = IASTPreprocessorBinaryExpression.K_LESS_THAN_OR_EQUALS;
                                break;
                        case GTE:
                                oper = IASTPreprocessorBinaryExpression.K_GREATER_THAN_OR_EQUALS;
                                break;
                        }
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppShiftExpression() throws ParseException {
        Token t = null;
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppAddExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SHL:
    case SHR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SHL:
        t = jj_consume_token(SHL);
        break;
      case SHR:
        t = jj_consume_token(SHR);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rhs = ppShiftExpression();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper;
                        if (t.kind == SHL)
                                oper = IASTPreprocessorBinaryExpression.K_SHL;
                        else
                                oper = IASTPreprocessorBinaryExpression.K_SHR;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppAddExpression() throws ParseException {
        Token t = null;
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppMulExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rhs = ppAddExpression();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper;
                        if (t.kind == PLUS)
                                oper = IASTPreprocessorBinaryExpression.K_ADD;
                        else
                                oper = IASTPreprocessorBinaryExpression.K_SUB;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else {
                        ret = lhs;
                }
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppMulExpression() throws ParseException {
        Token t = null;
        IASTPreprocessorExpression lhs, rhs=null;
        IASTPreprocessorExpression ret;
    lhs = ppUnaryExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TIMES:
    case DIV:
    case MOD:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TIMES:
        t = jj_consume_token(TIMES);
        break;
      case DIV:
        t = jj_consume_token(DIV);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rhs = ppMulExpression();
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
                if (rhs != null) {
                        int oper;
                        if (t.kind == TIMES)
                                oper = IASTPreprocessorBinaryExpression.K_MUL;
                        else if (t.kind == DIV)
                                oper = IASTPreprocessorBinaryExpression.K_DIV;
                        else
                                oper = IASTPreprocessorBinaryExpression.K_MOD;
                        ret = ASTFactory.createPreprocessorBinaryExpression(oper, lhs, rhs);
                        //setSourceRangeSpanning(ret, new IASTNode[] { lhs, rhs });
                } else
                        ret = lhs;
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppUnaryExpression() throws ParseException {
        Token t;
        IASTPreprocessorExpression expr = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case LPAREN:
    case DEFINED:
    case INTEGER:
      expr = ppPrimaryExpression();
                {if (true) return expr;}
      break;
    case PLUS:
    case MINUS:
    case NOT:
    case INVERT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      case NOT:
        t = jj_consume_token(NOT);
        break;
      case INVERT:
        t = jj_consume_token(INVERT);
        break;
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expr = ppPrimaryExpression();
                int oper = 0;
                switch (t.kind)
                {
                case MINUS:
                        oper = IASTPreprocessorUnaryExpression.K_NEGATE;
                        break;
                case NOT:
                        oper = IASTPreprocessorUnaryExpression.K_NOT;
                        break;
                case INVERT:
                        oper = IASTPreprocessorUnaryExpression.K_INVERT;
                        break;
                case PLUS:
                        oper = IASTPreprocessorUnaryExpression.K_PLUS;
                        break;
                }
                IASTPreprocessorExpression ret = ASTFactory.createPreprocessorUnaryExpression(
                        oper, expr);
                //setSourceRangeContaining(ret, t, expr, null);
                {if (true) return ret;}
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppPrimaryExpression() throws ParseException {
        IASTPreprocessorExpression expr = null;
        Token start;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      start = jj_consume_token(IDENTIFIER);
                expr = getPreprocessorLiteralExpressionSpanning(start, start);
                {if (true) return expr;}
      break;
    case LPAREN:
      start = jj_consume_token(LPAREN);
      expr = ppExpression();
      jj_consume_token(RPAREN);
                expr = ASTFactory.createPreprocessorUnaryExpression(
                        IASTPreprocessorUnaryExpression.K_PARENTHESIS, expr);
                //setSourceRange(expr, start, end);
                {if (true) return expr;}
      break;
    case DEFINED:
      start = jj_consume_token(DEFINED);
      expr = ppDefinedTail();
                // TODO: expand
                {if (true) return expr;}
      break;
    case INTEGER:
      expr = ppIntegralExpression();
                {if (true) return expr;}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorExpression ppDefinedTail() throws ParseException {
        Token id; //, lparen, rparen;
        IASTPreprocessorExpression expr;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      id = jj_consume_token(IDENTIFIER);
                expr = ASTFactory.createPreprocessorUnaryExpression(
                        IASTPreprocessorUnaryExpression.K_DEFINED,
                        ASTFactory.createPreprocessorLiteralExpression(id.image));
                //setSourceRange(expr, id, id);
                {if (true) return expr;}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      id = jj_consume_token(IDENTIFIER);
      jj_consume_token(RPAREN);
                expr = ASTFactory.createPreprocessorUnaryExpression(
                        IASTPreprocessorUnaryExpression.K_DEFINED,
                        ASTFactory.createPreprocessorLiteralExpression(id.image));
                //setSourceRange(expr, lparen, rparen);
                {if (true) return expr;}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IASTPreprocessorLiteralExpression ppIntegralExpression() throws ParseException {
        Token start;
        IASTPreprocessorLiteralExpression ret;
    start = jj_consume_token(INTEGER);
                ret = ASTFactory.createPreprocessorLiteralExpression(start.image);
                //setSourceRange(ret, start, start);
                //setExtendedSourceRangeFromComments(ret, false, false);
                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

// reference these tokens so they get enums...
  final public void TOKEN_HOLDER() throws ParseException {
    jj_consume_token(EOL);
  }

  final public void UNUSED() throws ParseException {
    jj_consume_token(ERROR);
    skip();
  }

  void skip() throws ParseException {
         getToken(1);
  }

  public TokenManager token_source;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[20];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x2,0x8,0x10,0x20,0x40,0x80,0x300,0x300,0x3c00,0x3c00,0xc000,0xc000,0x30000,0x30000,0x1c0000,0x1c0000,0x630000,0xde30000,0xd800000,0x1800000,};
   }


  public ASTParserCore(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[30];
    for (int i = 0; i < 30; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 20; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 30; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
